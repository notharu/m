
class Collection extends Map {
 constructor(IterableComponents) {
     super()
    if (IterableComponents instanceof Array) {
        for (const [key, value] of IterableComponents) {
            this.set(key, value)
        }
    } else if (IterableComponents instanceof Object) {
        for (const [key, value] of Object.entries(IterableComponents)) {
            this.set(key, value)
        }
     } else if (!IterableComponents) {

    } else {
        throw new TypeError("Components required to be instanceof Array/Object!")
    }

 }

 /**
  * Returns a Data of the First / given amount
  * @param {Number} amount - The amount from the Start
  */
 first(amount = 0) {
    if (isNaN(new Number(amount))) {
        return this.array()[0]
    }
    return this.array()[BigInt(amount)]
 }

 /**
  * Returns a Data of the Last / given amount from the Last
  * @param {Number} amount - The amount from the Last
  * 
  */

 last(amount = 0) {
    if (isNaN(new Number(amount))) {
        return this.array()[this.array().length - 1]
    }
    return this.array()[BigInt(this.array().length - 1) - BigInt(amount)]
 }

 /**
  * Returns an Array of Values of the Collection
  * @returns {Array}
  */

 array() {
    return Array.from(this.values())
 }

 keysArray() {
     return Array.from(this.keys())
 }

  /**
  * Returns a Data by Comparing values of each Keys
  * @param {Function} fn - A Function/Callback
  * @param {*} thisArg - Default Element if returning is undefined
  *  @returns {*}
  */

  find(fn, thisArg) {
     return this.filter(fn, thisArg).array()[0]
  }

  /**
  * Returns collection of Datas by Comparing values of each Keys
  * @param {Function} fn - A Function/Callback
  * @param {*} thisArg - Default Element if returning is undefined
  *  @returns {Collection}
  */

 filter(fn, thisArg) {
    if (thisArg) fn.bind(thisArg)
    const results = new Collection()
    for (const [key, val] of this.entries()) {
        if (fn(val, key, this)) results.set(key, val)
    }
    return results;
    }

  /**
  * Executes the given Callback for each Data
  * @param {Function} fn - A Function/Callback
  * @param {*} thisArg - Default value if undefined is returning
  */

  each(fn, thisArg) {
    return this.map(fn, thisArg)
  }

  /**
  * Executes the given Callback for each Data
  * @param {Function} fn - A Function/Callback
  * @param {*} thisArg - Default value if undefined is returning
  */

 forEach(fn, thisArg) {
    return this.map(fn, thisArg)
  }

  /**
   * Returns the first Key of Data
   * @param {Number} amount - The amount from the Start
   */

   firstKey(amount = 0) {
       if (isNaN(new Number(amount))) {
           return this.keysArray()[0]
       }
       return this.keysArray()[BigInt(amount)]
   }

   /**
   * Returns the Last Key of Data
   * @param {Number} amount - The amount from the Last
   */

    lastKey(amount = 0) {
    if (isNaN(new Number(amount))) {
        return this.keysArray()[this.keysArray().length - 1]
    }
    return this.keysArray()[BigInt(this.keysArray().length - 1) - BigInt(amount)]
    }

    /**
     * Clears the entire Data (Keys and Values)
     */

     clear() {
         this.each((v, k) => this.delete(k))
     }

     /**
      * Converts the Collection to Object
      */

     toObject() {
     const CollectionObject = {}
     this.map((value, key) => CollectionObject[key] = value)
     return CollectionObject
     }

     /**
      * Clones the Collection
      */

      clone() {
          return new Collection(Array.from(this.entries()))
      }

      /**
       * Merge Collections into one
       * @param  {...any} collections - Instanceof This Collection
       */

      concat(...collections) {
          const newCollection = this.clone()

          for (const col of collections) {
              if (!col instanceof Collection) {
                  new TypeError("Given data must be instanceof Collection!")
                  break;
              }
              for (const [key, val] of col.entries()) {
                  newCollection.set(key, val)
              }
          }

          return newCollection;
      }

      /**
       * Map values from each Keys
       * @param {Function} fn - A callback/function to map datas
       * @param {*} thisArg - Default Value if undefined is returning
       */

       map(fn, thisArg) {
        if (thisArg) fn.bind(thisArg)
         const iterables = this.entries()
         
         return Array.from({length: this.size}, () => {
             const [key, value] = iterables.next().value
             return fn(value, key, this)
         })
       }

       /**
        * Creates a new Collection with this and other collection without Modifying existing Data/Key
        */

        difference(otherCollection = new Collection()) {

            if (!otherCollection instanceof Collection) {
                throw new TypeError("Given data must be instanceof Collection!")
            }

            return otherCollection.filter((v, k) => !this.has(k)).concat(this.filter((v, k) => !otherCollection.has(k)))
        }

}

module.exports = Collection;
